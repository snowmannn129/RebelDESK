#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Docstring extraction module for the documentation generator.

This module provides functionality to extract and clean docstrings from
generated text for different programming languages.
"""

import re
from typing import Dict, Any, List, Optional

def extract_docstring_from_text(generated_text: str, language: str = 'python') -> str:
    """
    Extract a docstring from generated text.
    
    Args:
        generated_text (str): The text generated by the AI model.
        language (str, optional): The programming language.
        
    Returns:
        str: The extracted docstring.
    """
    if language == 'python':
        return _extract_python_docstring(generated_text)
    elif language in ['javascript', 'typescript']:
        return _extract_js_docstring(generated_text)
    elif language == 'cpp':
        return _extract_cpp_docstring(generated_text)
    elif language == 'java':
        return _extract_java_docstring(generated_text)
    else:
        return _extract_python_docstring(generated_text)  # Default to Python

def _extract_python_docstring(generated_text: str) -> str:
    """
    Extract a Python docstring from generated text.
    
    Args:
        generated_text (str): The text generated by the AI model.
        
    Returns:
        str: The extracted Python docstring.
    """
    # First, check if there's a triple-quoted string in the response
    triple_quote_pattern = r'"""(.*?)"""'
    triple_quotes = re.findall(triple_quote_pattern, generated_text, re.DOTALL)
    
    if triple_quotes:
        # Use the first triple-quoted string found
        return f'"""{triple_quotes[0]}"""'
    elif "Docstring:" in generated_text:
        # Try to extract after "Docstring:" marker
        return generated_text.split("Docstring:")[1].strip()
    else:
        # Try to extract a reasonable docstring from the text
        # Look for lines that seem to be part of a docstring
        lines = generated_text.strip().split('\n')
        
        # Detect if this is a thinking-heavy response
        thinking_indicators = [
            'okay so', 'let me', 'i need to', 'i should', 'i think',
            'the user wants', 'the docstring needs', 'i must', 'i will',
            'first', 'second', 'third', 'finally', 'in conclusion',
            'to summarize', 'to sum up', 'in summary'
        ]
        
        is_thinking_heavy = False
        thinking_line_count = 0
        
        for line in lines[:10]:  # Check first 10 lines
            line_lower = line.lower()
            if any(indicator in line_lower for indicator in thinking_indicators):
                thinking_line_count += 1
        
        # If more than 30% of the first lines are thinking, it's thinking-heavy
        is_thinking_heavy = thinking_line_count > 3
        
        # Different strategies based on whether it's thinking-heavy
        if is_thinking_heavy:
            # For thinking-heavy responses, try to extract just a concise description
            # Look for short, descriptive lines that don't contain thinking phrases
            thinking_phrases = [
                'should', 'need to', 'let me', 'i think', 'first', 
                'parameter', 'return', 'docstring should', 'include',
                'wait', 'hmm', 'now for', 'let\'s', 'what does', 'purpose',
                'structure', 'how to', 'additional info', 'potential', 'errors',
                'okay', 'so', 'the user', 'wants', 'needs', 'must', 'will',
                'second', 'third', 'finally', 'in conclusion', 'to summarize'
            ]
            
            # Try to find a concise description (first non-thinking line)
            description = None
            for line in lines:
                line_lower = line.lower()
                if (line.strip() and 
                    not any(x in line_lower for x in thinking_phrases) and
                    len(line) < 100):  # Not too long
                    description = line.strip()
                    break
            
            if description:
                # Create a minimal docstring with just the description
                return f'"""\n{description}\n"""'
            else:
                # Fallback to template-based minimal docstring
                return '"""\nDescription of the function or method.\n"""'
        else:
            # For normal responses, use the original approach
            docstring_lines = []
            
            # Skip initial lines that seem to be thinking/instructions
            start_collecting = False
            thinking_phrases = [
                'should', 'need to', 'let me', 'i think', 'first', 
                'parameter', 'return', 'docstring should', 'include',
                'wait', 'hmm', 'now for', 'let\'s', 'what does', 'purpose',
                'structure', 'how to', 'additional info', 'potential', 'errors'
            ]
            
            # First pass: try to find a clean docstring without thinking
            for i, line in enumerate(lines):
                line_lower = line.lower()
                # Skip lines that look like the model thinking about what to write
                if not start_collecting:
                    if line.strip() and not any(x in line_lower for x in thinking_phrases):
                        start_collecting = True
                elif any(x in line_lower for x in thinking_phrases) and i > 0:
                    # Stop collecting if we hit thinking phrases after we started
                    break
                
                if start_collecting:
                    docstring_lines.append(line)
            
            # If we didn't find anything reasonable, try a more lenient approach
            if not docstring_lines:
                start_collecting = False
                for line in lines:
                    # Skip lines that explicitly look like thinking
                    if not start_collecting:
                        if line.strip() and not line.lower().startswith(('let me', 'i think', 'wait', 'hmm')):
                            start_collecting = True
                    
                    if start_collecting:
                        docstring_lines.append(line)
            
            # If we found some reasonable lines, use them
            if docstring_lines:
                return '\n'.join(docstring_lines).strip()
            else:
                # Fallback to using the whole text
                return generated_text.strip()

def _extract_js_docstring(generated_text: str) -> str:
    """
    Extract a JavaScript/TypeScript docstring from generated text.
    
    Args:
        generated_text (str): The text generated by the AI model.
        
    Returns:
        str: The extracted JavaScript/TypeScript docstring.
    """
    # Check for JSDoc style comments
    jsdoc_pattern = r'/\*\*([\s\S]*?)\*/'
    jsdoc_matches = re.findall(jsdoc_pattern, generated_text, re.DOTALL)
    
    if jsdoc_matches:
        # Use the first JSDoc comment found
        return f'/**{jsdoc_matches[0]}*/'
    elif "Docstring:" in generated_text:
        # Try to extract after "Docstring:" marker
        docstring = generated_text.split("Docstring:")[1].strip()
        # Convert to JSDoc format if it's not already
        if not docstring.startswith('/**'):
            lines = docstring.split('\n')
            formatted_lines = ['/**']
            for line in lines:
                formatted_lines.append(f' * {line}')
            formatted_lines.append(' */')
            return '\n'.join(formatted_lines)
        return docstring
    else:
        # Try to extract a reasonable docstring from the text
        lines = generated_text.strip().split('\n')
        
        # Filter out thinking lines
        thinking_phrases = [
            'should', 'need to', 'let me', 'i think', 'first', 
            'parameter', 'return', 'docstring should', 'include',
            'wait', 'hmm', 'now for', 'let\'s', 'what does', 'purpose'
        ]
        
        filtered_lines = []
        for line in lines:
            line_lower = line.lower()
            if not any(phrase in line_lower for phrase in thinking_phrases):
                filtered_lines.append(line)
        
        # If we have some reasonable content, format it as JSDoc
        if filtered_lines:
            description = filtered_lines[0].strip()
            jsdoc = ['/**']
            jsdoc.append(f' * {description}')
            jsdoc.append(' *')
            
            # Look for @param and @returns tags
            param_pattern = r'@param\s+\{.*?\}\s+\w+'
            returns_pattern = r'@returns?\s+\{.*?\}'
            
            for line in filtered_lines[1:]:
                if re.search(param_pattern, line) or re.search(returns_pattern, line):
                    jsdoc.append(f' * {line.strip()}')
                elif 'param' in line.lower() and ':' in line:
                    # Try to convert to @param format
                    parts = line.split(':', 1)
                    param_name = parts[0].strip().split()[-1]
                    param_desc = parts[1].strip()
                    jsdoc.append(f' * @param {{{param_name}}} {param_desc}')
                elif 'return' in line.lower() and ':' in line:
                    # Try to convert to @returns format
                    return_desc = line.split(':', 1)[1].strip()
                    jsdoc.append(f' * @returns {return_desc}')
                else:
                    jsdoc.append(f' * {line.strip()}')
            
            jsdoc.append(' */')
            return '\n'.join(jsdoc)
        else:
            # Fallback to a minimal JSDoc comment
            return '/**\n * Description of the function or method.\n */'

def _extract_cpp_docstring(generated_text: str) -> str:
    """
    Extract a C++ docstring from generated text.
    
    Args:
        generated_text (str): The text generated by the AI model.
        
    Returns:
        str: The extracted C++ docstring.
    """
    # Check for Doxygen style comments
    doxygen_pattern = r'/\*\*([\s\S]*?)\*/'
    doxygen_matches = re.findall(doxygen_pattern, generated_text, re.DOTALL)
    
    if doxygen_matches:
        # Use the first Doxygen comment found
        return f'/**{doxygen_matches[0]}*/'
    elif "Docstring:" in generated_text:
        # Try to extract after "Docstring:" marker
        docstring = generated_text.split("Docstring:")[1].strip()
        # Convert to Doxygen format if it's not already
        if not docstring.startswith('/**'):
            lines = docstring.split('\n')
            formatted_lines = ['/**']
            for line in lines:
                formatted_lines.append(f' * {line}')
            formatted_lines.append(' */')
            return '\n'.join(formatted_lines)
        return docstring
    else:
        # Try to extract a reasonable docstring from the text
        lines = generated_text.strip().split('\n')
        
        # Filter out thinking lines
        thinking_phrases = [
            'should', 'need to', 'let me', 'i think', 'first', 
            'parameter', 'return', 'docstring should', 'include',
            'wait', 'hmm', 'now for', 'let\'s', 'what does', 'purpose'
        ]
        
        filtered_lines = []
        for line in lines:
            line_lower = line.lower()
            if not any(phrase in line_lower for phrase in thinking_phrases):
                filtered_lines.append(line)
        
        # If we have some reasonable content, format it as Doxygen
        if filtered_lines:
            description = filtered_lines[0].strip()
            doxygen = ['/**']
            doxygen.append(f' * {description}')
            doxygen.append(' *')
            
            # Look for @param and @return tags
            param_pattern = r'@param\s+\w+'
            return_pattern = r'@return'
            
            for line in filtered_lines[1:]:
                if re.search(param_pattern, line) or re.search(return_pattern, line):
                    doxygen.append(f' * {line.strip()}')
                elif 'param' in line.lower() and ':' in line:
                    # Try to convert to @param format
                    parts = line.split(':', 1)
                    param_name = parts[0].strip().split()[-1]
                    param_desc = parts[1].strip()
                    doxygen.append(f' * @param {param_name} {param_desc}')
                elif 'return' in line.lower() and ':' in line:
                    # Try to convert to @return format
                    return_desc = line.split(':', 1)[1].strip()
                    doxygen.append(f' * @return {return_desc}')
                else:
                    doxygen.append(f' * {line.strip()}')
            
            doxygen.append(' */')
            return '\n'.join(doxygen)
        else:
            # Fallback to a minimal Doxygen comment
            return '/**\n * Description of the function or method.\n */'

def _extract_java_docstring(generated_text: str) -> str:
    """
    Extract a Java docstring from generated text.
    
    Args:
        generated_text (str): The text generated by the AI model.
        
    Returns:
        str: The extracted Java docstring.
    """
    # Check for Javadoc style comments
    javadoc_pattern = r'/\*\*([\s\S]*?)\*/'
    javadoc_matches = re.findall(javadoc_pattern, generated_text, re.DOTALL)
    
    if javadoc_matches:
        # Use the first Javadoc comment found
        return f'/**{javadoc_matches[0]}*/'
    elif "Docstring:" in generated_text:
        # Try to extract after "Docstring:" marker
        docstring = generated_text.split("Docstring:")[1].strip()
        # Convert to Javadoc format if it's not already
        if not docstring.startswith('/**'):
            lines = docstring.split('\n')
            formatted_lines = ['/**']
            for line in lines:
                formatted_lines.append(f' * {line}')
            formatted_lines.append(' */')
            return '\n'.join(formatted_lines)
        return docstring
    else:
        # Try to extract a reasonable docstring from the text
        lines = generated_text.strip().split('\n')
        
        # Filter out thinking lines
        thinking_phrases = [
            'should', 'need to', 'let me', 'i think', 'first', 
            'parameter', 'return', 'docstring should', 'include',
            'wait', 'hmm', 'now for', 'let\'s', 'what does', 'purpose'
        ]
        
        filtered_lines = []
        for line in lines:
            line_lower = line.lower()
            if not any(phrase in line_lower for phrase in thinking_phrases):
                filtered_lines.append(line)
        
        # If we have some reasonable content, format it as Javadoc
        if filtered_lines:
            description = filtered_lines[0].strip()
            javadoc = ['/**']
            javadoc.append(f' * {description}')
            javadoc.append(' *')
            
            # Look for @param and @return tags
            param_pattern = r'@param\s+\w+'
            return_pattern = r'@return'
            
            for line in filtered_lines[1:]:
                if re.search(param_pattern, line) or re.search(return_pattern, line):
                    javadoc.append(f' * {line.strip()}')
                elif 'param' in line.lower() and ':' in line:
                    # Try to convert to @param format
                    parts = line.split(':', 1)
                    param_name = parts[0].strip().split()[-1]
                    param_desc = parts[1].strip()
                    javadoc.append(f' * @param {param_name} {param_desc}')
                elif 'return' in line.lower() and ':' in line:
                    # Try to convert to @return format
                    return_desc = line.split(':', 1)[1].strip()
                    javadoc.append(f' * @return {return_desc}')
                else:
                    javadoc.append(f' * {line.strip()}')
            
            javadoc.append(' */')
            return '\n'.join(javadoc)
        else:
            # Fallback to a minimal Javadoc comment
            return '/**\n * Description of the function or method.\n */'

def clean_docstring(docstring: str, language: str = 'python') -> str:
    """
    Clean up a generated docstring.
    
    Args:
        docstring (str): The docstring to clean.
        language (str, optional): The programming language.
        
    Returns:
        str: The cleaned docstring.
    """
    # Remove any leading/trailing whitespace
    docstring = docstring.strip()
    
    if language == 'python':
        # Ensure the docstring is properly formatted for Python
        if not docstring.startswith('"""') and not docstring.startswith("'''"):
            docstring = f'"""\n{docstring}\n"""'
            
        # Remove any extra quotes
        docstring = re.sub(r'^["\']+', '"""', docstring)
        docstring = re.sub(r'["\']+$', '"""', docstring)
    elif language in ['javascript', 'typescript', 'cpp', 'java']:
        # Ensure the docstring is properly formatted for JS/TS/C++/Java
        if not docstring.startswith('/**'):
            # Convert to JSDoc/Doxygen/Javadoc format
            lines = docstring.split('\n')
            formatted_lines = ['/**']
            for line in lines:
                formatted_lines.append(f' * {line}')
            formatted_lines.append(' */')
            docstring = '\n'.join(formatted_lines)
        
        # Make sure it ends with */
        if not docstring.rstrip().endswith('*/'):
            docstring = docstring.rstrip() + '\n */'
    
    return docstring
