# Documentation Generator Improvements

## Current Status
The DocumentationGenerator class is implemented and integrated with the code completion system. It provides documentation generation for Python code elements such as functions, classes, and methods. The implementation supports both local models and API-based models, with a template-based fallback.

## Limitations
1. **Python-only support**: Currently, the documentation generator only supports Python code.
2. **Test integration**: There are test scripts for testing with LMStudio, but they're not integrated into the main test suite.
3. **Docstring extraction**: The docstring extraction and cleaning could be improved for better results.
4. **Edge cases**: More comprehensive tests for edge cases are needed.

## Improvement Plan

### 1. Add Support for Additional Languages
- Implement language-specific parsers for JavaScript, TypeScript, C++, and Java
- Create language-specific docstring templates
- Add language detection based on file extension and content

```python
def _detect_language(self, code: str, file_path: Optional[str] = None, language: Optional[str] = None) -> str:
    """
    Detect the programming language of the code.
    
    Args:
        code (str): The code to analyze.
        file_path (str, optional): The path to the file being edited.
        language (str, optional): The programming language if already known.
        
    Returns:
        str: The detected programming language.
    """
    if language:
        return language.lower()
        
    # Try to determine language from file extension
    if file_path:
        ext = os.path.splitext(file_path)[1].lower()
        if ext == '.py':
            return 'python'
        elif ext in ['.js', '.jsx']:
            return 'javascript'
        elif ext in ['.ts', '.tsx']:
            return 'typescript'
        elif ext in ['.cpp', '.h', '.hpp']:
            return 'cpp'
        elif ext == '.java':
            return 'java'
    
    # Default to Python if language can't be determined
    return 'python'
```

### 2. Integrate LMStudio Tests into Main Test Suite
- Create a new test file `test_lmstudio_integration.py` in the `src/tests` directory
- Add tests for LMStudio integration with proper mocking for CI/CD
- Add configuration options for test-specific LMStudio settings

```python
@unittest.skipIf(not os.environ.get('TEST_LMSTUDIO'), "LMStudio tests disabled")
def test_lmstudio_integration(self):
    """Test integration with LMStudio."""
    # Create a test configuration with LMStudio
    config = {
        'ai': {
            'enable': True,
            'model': {
                'type': 'local',
                'api_endpoint': os.environ.get('LMSTUDIO_ENDPOINT', 'http://127.0.0.1:1234/v1/completions')
            }
        }
    }
    
    # Create the documentation generator
    doc_generator = DocumentationGenerator(config)
    
    # Test code
    code = "def test_function():\n    pass"
    
    # Generate docstring
    docstring = doc_generator.generate_function_docstring(code, "test_function")
    
    # Check that a docstring was generated
    self.assertIsNotNone(docstring)
    self.assertIn('"""', docstring)
```

### 3. Improve Docstring Extraction and Cleaning
- Enhance the regex patterns for better docstring extraction
- Add more sophisticated cleaning for different docstring styles
- Implement language-specific docstring formatting

```python
def _extract_docstring_from_text(self, generated_text: str, language: str = 'python') -> str:
    """
    Extract a docstring from generated text.
    
    Args:
        generated_text (str): The text generated by the AI model.
        language (str, optional): The programming language.
        
    Returns:
        str: The extracted docstring.
    """
    if language == 'python':
        return self._extract_python_docstring(generated_text)
    elif language in ['javascript', 'typescript']:
        return self._extract_js_docstring(generated_text)
    elif language == 'cpp':
        return self._extract_cpp_docstring(generated_text)
    elif language == 'java':
        return self._extract_java_docstring(generated_text)
    else:
        return self._extract_python_docstring(generated_text)  # Default to Python
```

### 4. Add Comprehensive Tests for Edge Cases
- Add tests for empty code
- Add tests for code with syntax errors
- Add tests for code with existing docstrings
- Add tests for code with unusual formatting

```python
def test_empty_code(self):
    """Test handling of empty code."""
    # Test with empty code
    docstring = self.doc_generator.generate_function_docstring("", "test_function")
    
    # Check that None is returned
    self.assertIsNone(docstring)
    
def test_code_with_syntax_errors(self):
    """Test handling of code with syntax errors."""
    # Test code with syntax errors
    code = "def test_function(:\n    pass"
    
    # Generate docstring
    docstring = self.doc_generator.generate_function_docstring(code, "test_function")
    
    # Check that None is returned
    self.assertIsNone(docstring)
    
def test_code_with_existing_docstring(self):
    """Test handling of code with existing docstring."""
    # Test code with existing docstring
    code = 'def test_function():\n    """Existing docstring."""\n    pass'
    
    # Generate docstring
    docstring = self.doc_generator.generate_function_docstring(code, "test_function")
    
    # Check that the existing docstring is preserved or enhanced
    self.assertIsNotNone(docstring)
    self.assertIn('Existing docstring', docstring)
```

## Implementation Timeline
1. **Week 1**: Add support for JavaScript and TypeScript
2. **Week 2**: Add support for C++ and Java
3. **Week 3**: Integrate LMStudio tests into main test suite
4. **Week 4**: Improve docstring extraction and cleaning
5. **Week 5**: Add comprehensive tests for edge cases

## Conclusion
These improvements will enhance the documentation generator's capabilities, making it more robust and versatile. The addition of support for multiple languages will make it more useful for a wider range of projects, while the improved testing will ensure its reliability.
